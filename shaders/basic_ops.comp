#version 450

layout(local_size_x = 256) in;

layout(set = 0, binding = 0) buffer InputA {
    float a[];
};

layout(set = 0, binding = 1) buffer InputB {
    float b[];
};

layout(set = 0, binding = 2) buffer Output {
    float result[];
};

layout(push_constant) uniform PushConstants {
    uint op_type;    // 0: add, 1: multiply, 2: divide, 3: subtract, 4: matmul
    uint data_length;
    uint m;          // matrix dimensions for matmul
    uint n;
    uint k;
} push_constants;

void main() {
    uint idx = gl_GlobalInvocationID.x;
    if (idx >= push_constants.data_length) return;

    float val_a = a[idx];
    float val_b = b[idx];
    
    switch(push_constants.op_type) {
        case 0:
            result[idx] = val_a + val_b;
            break;
        case 1:
            result[idx] = val_a * val_b;
            break;
        case 2:
            result[idx] = val_a / val_b;
            break;
        case 3:
            result[idx] = val_a - val_b;
            break;
        case 4: // Matrix multiplication
            uint total_idx = gl_GlobalInvocationID.x;
            if (total_idx >= push_constants.m * push_constants.k) return;
            
            uint row = total_idx / push_constants.k;
            uint col = total_idx % push_constants.k;
            float sum = 0.0;
            
            for (uint i = 0; i < push_constants.n; i++) {
                sum += a[row * push_constants.n + i] * b[i * push_constants.k + col];
            }
            result[total_idx] = sum;
            break;
    }
} 